// Copyright 2023 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

// Binary gen_clang_flags generates clang_flags.go from Options.td json output.
//
// Usage:
//
//	$ llvm-tblgen \
//	    -I../llvm/include \
//	    -I../clang/include/clang/Driver \
//	    ../clang/include/clang/Driver/Options.td \
//	 | gen_clang_flags -o clang_flags.go
package main

import (
	"bytes"
	"encoding/json"
	"flag"
	"fmt"
	"go/format"
	"log"
	"os"
	"sort"
	"text/template"
)

var (
	verbose = flag.Bool("v", false, "verbose")
	input   = flag.String("input", "", "Options.td json path")
	output  = flag.String("o", "clang_flags.go", "output file")
)

//
// Options.td json dump format:
//
//  <key>: {
//    "Name": <string>, # name of flag.
//    "Prefixes": [<string>, ..], # prefix of flag. "-", "--", ..
//    "Kind": {.., "def":<string>, ..} # kind def
//    "NumArgs": <number>,  # number of args for MultiArgs
//    "Flags": [{.., "def":<string>, ..}, ..], # options
//    ...,
//  }
//
//
// kind: see llvm/include/llvm/Option/OptParser.td
//   // An option group.
//   def KIND_GROUP : OptionKind<"Group">;
//   // The input option kind.
//   def KIND_INPUT : OptionKind<"Input", 1, 1>;
//   // The unknown option kind.
//   def KIND_UNKNOWN : OptionKind<"Unknown", 2, 1>;
//   // A flag with no values.
//   def KIND_FLAG : OptionKind<"Flag">;
//   // An option which prefixes its (single) value.
//   def KIND_JOINED : OptionKind<"Joined", 1>;
//   // An option which is followed by its value.
//   def KIND_SEPARATE : OptionKind<"Separate">;
//   // An option followed by its values, which are separated by commas.
//   def KIND_COMMAJOINED : OptionKind<"CommaJoined">;
//   // An option which is which takes multiple (separate) arguments.
//   def KIND_MULTIARG : OptionKind<"MultiArg">;
//   // An option which is either joined to its (non-empty) value, or followed by its
//   // value.
//   def KIND_JOINED_OR_SEPARATE : OptionKind<"JoinedOrSeparate">;
//   // An option which is both joined to its (first) value, and followed by its
//   // (second) value.
//   def KIND_JOINED_AND_SEPARATE : OptionKind<"JoinedAndSeparate">;
//   // An option which consumes all remaining arguments if there are any.
//   def KIND_REMAINING_ARGS : OptionKind<"RemainingArgs">;
//   // An option which consumes an optional joined argument and any other remaining
//   // arguments.
//   def KIND_REMAINING_ARGS_JOINED : OptionKind<"RemainingArgsJoined">;
//
// flags: see clang/include/clang/Driver/Options.td
//  // DriverOption - The option is a "driver" option, and should not be forwarded
//  // to other tools.
//  def DriverOption : OptionFlag;
//
//  // LinkerInput - The option is a linker input.
//  def LinkerInput : OptionFlag;
//
//  // NoArgumentUnused - Don't report argument unused warnings for this option; this
//  // is useful for options like -static or -dynamic which a user may always end up
//  // passing, even if the platform defaults to (or only supports) that option.
//  def NoArgumentUnused : OptionFlag;
//
//  // Unsupported - The option is unsupported, and the driver will reject command
//  // lines that use it.
//  def Unsupported : OptionFlag;
//
//  // Ignored - The option is unsupported, and the driver will silently ignore it.
//  def Ignored : OptionFlag;
//
//  // CoreOption - This is considered a "core" Clang option, available in both
//  // clang and clang-cl modes.
//  def CoreOption : OptionFlag;
//
//  // CLOption - This is a cl.exe compatibility option. Options with this flag
//  // are made available when the driver is running in CL compatibility mode.
//  def CLOption : OptionFlag;
//
//  // CC1Option - This option should be accepted by clang -cc1.
//  def CC1Option : OptionFlag;
//
//  // CC1AsOption - This option should be accepted by clang -cc1as.
//  def CC1AsOption : OptionFlag;
//
//  // NoDriverOption - This option should not be accepted by the driver.
//  def NoDriverOption : OptionFlag;

var (
	tmpl = template.Must(template.New("").Parse(`
package clangparser

import "github.com/bazelbuild/reclient/internal/pkg/inputprocessor/args"

// DO NOT EDIT: this is autogenerated by
//  {{.Generator}}

var (
  // ClangOptions is clang's flag options.
  ClangOptions = map[string]int{
{{range $k, $v := .Clang.Options -}}
    {{printf "%q" $k}}: {{$v}},
{{end -}}
}

  // ClangPrefixes is clang's prefix flag options.
  ClangPrefixes = []args.PrefixOption{
{{range .Clang.Prefixes -}}
   {Prefix: {{printf "%q" .Prefix}}, NumArgs: {{.NumArgs}}},
{{end -}}
}

  // ClangNormalizedFlags is clang's normalized flags.
  ClangNormalizedFlags = map[string]string{
{{range $k, $v := .Clang.NormalizedFlags -}}
    {{printf "%q" $k}}: {{printf "%q" $v}},
{{end -}}
}

  // ClangCLOptions is clang's flag options.
  ClangCLOptions = map[string]int{
{{range $k, $v := .ClangCL.Options -}}
    {{printf "%q" $k}}: {{$v}},
{{end -}}
}

  // ClangPrefixes is clang's prefix flag options.
  ClangCLPrefixes = []args.PrefixOption{
{{range .ClangCL.Prefixes -}}
   {Prefix: {{printf "%q" .Prefix}}, NumArgs: {{.NumArgs}}},
{{end -}}
}

  // ClangNormalizedFlags is clang's normalized flags.
  ClangCLNormalizedFlags = map[string]string{
{{range $k, $v := .ClangCL.NormalizedFlags -}}
    {{printf "%q" $k}}: {{printf "%q" $v}},
{{end -}}
}

)
`))
)

func main() {
	flag.Parse()
	if *input == "" {
		log.Fatalf("need to specify --input /path/to/clang_options.json")
	}
	content, err := os.ReadFile(*input)
	if err != nil {
		log.Fatalf("read %s: %v", *input, err)
	}
	m := make(map[string]interface{})
	err = json.Unmarshal(content, &m)
	if err != nil {
		log.Fatalf("unmarshal json %s: %v", *input, err)
	}
	options, err := parseOptions(m)
	if err != nil {
		log.Fatalf("parse error %s: %v", *input, err)
	}
	var buf bytes.Buffer
	err = tmpl.Execute(&buf, options)
	if err != nil {
		log.Fatalf("template error %v", err)
	}
	source, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatalf("fmt error: %v\n%s", err, buf.Bytes())
	}
	err = os.WriteFile(*output, source, 0644)
	if err != nil {
		log.Fatalf("write %s: %v", *output, err)
	}
}

type prefixOption struct {
	Prefix  string
	NumArgs int
}

// OptionDefs holds options definition of the command.
type OptionDefs struct {
	// Options is for
	//   KIND_FLAG (value=0)
	//   KIND_SEPARATE (value=1)
	//   KIND_MULTIARG (value=NumArgs)
	//   KIND_JOINED_OR_SEPARATE (value=1)
	//   KIND_REMAINING_ARGS (value < 0)
	Options map[string]int

	// Prefixes is for
	//   KIND_COMMAJOINED, KIND_JOINED, KIND_JOINED_OR_SEPARATE (NumArgs = 0)
	//   KIND_JOINED_AND_SEPARETE (NumArgs = 1)
	//   KIND_REMAINING_ARGS_JOINED (NumArgs < 1).
	Prefixes []prefixOption

	// NormalizedFlags is a map to flag to a normalized flag
	// for flag that have several flag prefixes. e.g. "/" and "-".
	NormalizedFlags map[string]string
}

// Options holds clang and clang-cl options definition.
type Options struct {
	// Generator is command line of generator.
	Generator []string

	// Clang includes flags except CLOption, NoDriverOption.
	Clang OptionDefs

	// ClangCL includes CLOption and CoreOption.
	ClangCL OptionDefs
}

func parseOptions(m map[string]interface{}) (Options, error) {
	options := Options{
		Generator: os.Args,
		Clang: OptionDefs{
			Options:         make(map[string]int),
			NormalizedFlags: make(map[string]string),
		},
		ClangCL: OptionDefs{
			Options:         make(map[string]int),
			NormalizedFlags: make(map[string]string),
		},
	}
	for key, val := range m {
		v, ok := val.(map[string]interface{})
		if !ok {
			if *verbose {
				log.Printf("key %q is unexpected type: %T", key, val)
			}
			continue
		}
		if !isOptionClass(v) {
			if *verbose {
				log.Printf("key %s is not Option class: %v", key, v)
			}
			continue
		}
		o, err := parseOpt(v)
		if err != nil {
			return options, fmt.Errorf("invalid option for key %s: %v", key, err)
		}
		if *verbose {
			log.Printf("key %s option %v", key, o)
		}
		if len(o.visibility) > 0 && !contains(o.visibility, "DefaultVis") && !contains(o.visibility, "CLOption") {
			if *verbose {
				log.Printf("key %s skip ", key)
			}
			continue
		}
		switch {
		case contains(o.visibility, "DefaultVis"):
			err = setOption(&options.Clang, o)
			if err != nil {
				return options, fmt.Errorf("set %v in clang: %v", o, err)
			}
			err = setOption(&options.ClangCL, o)
			if err != nil {
				return options, fmt.Errorf("set %v in clang-cl: %v", o, err)
			}
		case contains(o.visibility, "CLOption"):
			err = setOption(&options.ClangCL, o)
			if err != nil {
				return options, fmt.Errorf("set %v in clang-cl: %v", o, err)
			}
		default:
			err = setOption(&options.Clang, o)
			if err != nil {
				return options, fmt.Errorf("set %v in clang: %v", o, err)
			}
		}
	}
	sort.Slice(options.Clang.Prefixes, func(i, j int) bool {
		return options.Clang.Prefixes[i].Prefix > options.Clang.Prefixes[j].Prefix
	})
	sort.Slice(options.ClangCL.Prefixes, func(i, j int) bool {
		return options.ClangCL.Prefixes[i].Prefix > options.ClangCL.Prefixes[j].Prefix
	})
	return options, nil
}

func setOption(od *OptionDefs, o opt) error {
	for _, prefix := range o.prefixes {
		flag := prefix + o.name
		if *verbose {
			log.Printf("set %q %s (%d)", flag, o.kind, o.numArgs)
		}
		switch o.kind {
		case "KIND_COMMAJOINED":
			od.Prefixes = append(od.Prefixes, prefixOption{flag, 0})
		case "KIND_FLAG":
			od.Options[flag] = 0
		case "KIND_JOINED":
			od.Prefixes = append(od.Prefixes, prefixOption{flag, 0})
		case "KIND_JOINED_AND_SEPARATE":
			od.Prefixes = append(od.Prefixes, prefixOption{flag, 1})
		case "KIND_JOINED_OR_SEPARATE":
			od.Options[flag] = 1
			od.Prefixes = append(od.Prefixes, prefixOption{flag, 0})
		case "KIND_MULTIARG":
			od.Options[flag] = o.numArgs
		case "KIND_SEPARATE":
			od.Options[flag] = 1
		case "KIND_REMAINING_ARGS":
			od.Options[flag] = -1
		case "KIND_REMAINING_ARGS_JOINED":
			od.Prefixes = append(od.Prefixes, prefixOption{flag, -1})
		default:
			return fmt.Errorf("unknown kind %q in %v", o.kind, o)
		}
	}
	if len(o.prefixes) > 1 {
		// ["/", "-"] => normalized to "-"
		normalizedFlag := o.prefixes[len(o.prefixes)-1] + o.name
		for _, prefix := range o.prefixes[:len(o.prefixes)-1] {
			flag := prefix + o.name
			od.NormalizedFlags[flag] = normalizedFlag
		}
	}
	return nil
}

// helpers

type opt struct {
	kind       string
	name       string
	prefixes   []string
	numArgs    int
	visibility []string
}

func parseOpt(m map[string]interface{}) (opt, error) {
	var o opt
	var ok bool
	o.kind, ok = getDef(m, "Kind")
	if !ok {
		return o, fmt.Errorf("`Kind` not found in %v", m)
	}
	o.name, ok = getString(m, "Name")
	if !ok {
		return o, fmt.Errorf("`Name` not found in %v", m)
	}
	o.prefixes, ok = getStrings(m, "Prefixes")
	if !ok {
		return o, fmt.Errorf("`Prefixes` not found in %v", m)
	}
	o.numArgs, _ = getInt(m, "NumArgs")
	switch o.kind {
	case "KIND_JOINED_AND_SEPARATE", "KIND_SEPARATE":
		o.numArgs = 1
	case "KIND_REMAINING_ARGS", "KIND_REMAINING_ARGS_JOIND":
		o.numArgs = -1
	}
	o.visibility, ok = getDefs(m, "Visibility")
	if !ok {
		return o, fmt.Errorf("`Visibility` not found in %v", m)
	}
	return o, nil
}

func isOptionClass(m map[string]interface{}) bool {
	superclasses, ok := getStrings(m, "!superclasses")
	if !ok {
		return false
	}
	if !contains(superclasses, "Option") {
		return false
	}
	return true
}

func getString(m map[string]interface{}, key string) (string, bool) {
	v, ok := m[key].(string)
	return v, ok
}

func getInt(m map[string]interface{}, key string) (int, bool) {
	v, ok := m[key].(float64)
	return int(v), ok
}

func getStrings(m map[string]interface{}, key string) ([]string, bool) {
	v, ok := m[key].([]interface{})
	if !ok {
		return nil, false
	}
	var ret []string
	for _, e := range v {
		s, ok := e.(string)
		if !ok {
			return nil, false
		}
		ret = append(ret, s)
	}
	return ret, true
}

func getDef(m map[string]interface{}, key string) (string, bool) {
	v, ok := m[key].(map[string]interface{})
	if !ok {
		return "", false
	}
	def, ok := v["def"].(string)
	if !ok {
		return "", false
	}
	return def, true
}

func getDefs(m map[string]interface{}, key string) ([]string, bool) {
	vs, ok := m[key].([]interface{})
	if !ok {
		return nil, false
	}
	var defs []string
	for _, v := range vs {
		vm, ok := v.(map[string]interface{})
		if !ok {
			return nil, false
		}
		def, ok := vm["def"].(string)
		if !ok {
			return nil, false
		}
		defs = append(defs, def)
	}
	return defs, true
}

func contains(list []string, s string) bool {
	for _, v := range list {
		if v == s {
			return true
		}
	}
	return false
}
